alwaystrue : 1
#twomuon    : nVetoElectrons == 0 && nMuon >= 2
twomuon    : Sum(vetoMuons)==2 && Sum(goodMuons)==2 
trigger    : HLT_SingleMu24 > 0
oppositecharge : (Muon_charge[goodMuons][0] + Muon_charge[goodMuons][1]) == 0
#accept     : std\:\:abs(Muon_eta[goodMuons][0]) < 2.4 && std\:\:abs(Muon_eta[goodMuons][1]) < 2.4 && valueInsideRange(Muon_pt[goodMuons][0],26,55) && valueInsideRange(Muon_pt[goodMuons][1],26,55)
# pt > 26 already in definition of good muons
accept     : std\:\:abs(Muon_eta[goodMuons][0]) < 2.4 && std\:\:abs(Muon_eta[goodMuons][1]) < 2.4
muonID     : Muon_mediumId[goodMuons][0] == 1 && Muon_mediumId[goodMuons][1] == 1
pfRelIso04 : Muon_pfRelIso04_all[goodMuons][0] < 0.15 && Muon_pfRelIso04_all[goodMuons][1] < 0.15
#dxy        : std\:\:abs(Muon_dxy[goodMuons][0]) < 0.05 && std\:\:abs(Muon_dxy[goodMuons][1]) < 0.05
#dz         : std\:\:abs(Muon_dz[goodMuons][0]) < 0.2 && std\:\:abs(Muon_dz[goodMuons][1]) < 0.2
mZ         : valueInsideRange(invariantmass(Muon_pt[goodMuons],Muon_eta[goodMuons],Muon_phi[goodMuons],Muon_mass[goodMuons]), 60., 120.)
## mT cut to be added once we understand what MET to use
mtl1pf40   : mt_wlike_nano(Muon_pt[goodMuonsCharge][0],Muon_phi[goodMuonsCharge][0],Muon_pt[goodMuonsOther][1],Muon_phi[goodMuonsOther][1],MET_T1_pt,MET_T1_phi) > 40.

